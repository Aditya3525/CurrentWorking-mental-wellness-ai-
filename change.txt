AdminDashboard
import { 
  Plus, 
  LogOut, 
  Brain, 
  BookOpen, 
  Shield,
  Menu,
  X,
  FileText,
  Headphones,
  Video,
  BookMarked,
  Mic,
  Heart,
  Loader2,
  AlertCircle,
  Clock
} from 'lucide-react';
import React, { useCallback, useEffect, useMemo, useState } from 'react';

import { Badge } from '../components/ui/badge';
import { Button } from '../components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '../components/ui/card';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogFooter, DialogClose } from '../components/ui/dialog';
import { ScrollArea } from '../components/ui/scroll-area';
import { Skeleton } from '../components/ui/skeleton';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '../components/ui/tabs';
import { useAdminAuth } from '../contexts/AdminAuthContext';
import { useToast } from '../contexts/ToastContext';

import { ContentForm, ContentRecord } from './ContentForm';
import { ContentList, ContentItem } from './ContentList';
import { PracticeForm, PracticeRecord } from './PracticeForm';
import { PracticesList, Practice } from './PracticesList';

type ToastPush = (toast: { title: string; description?: string; type: 'success' | 'error' | 'warning' | 'info'; duration?: number }) => void;

type AdminUser = { id: string; email: string; role: string; name?: string } | null;

const PRACTICE_LEVELS: Practice['level'][] = ['Beginner', 'Intermediate', 'Advanced'];

const normalizePracticeLevel = (level?: string | null): Practice['level'] => {
  if (level && PRACTICE_LEVELS.includes(level as Practice['level'])) {
    return level as Practice['level'];
  }
  return 'Beginner';
};

const normalizeTags = (raw?: string[] | string | null): string[] => {
  if (!raw) return [];
  if (Array.isArray(raw)) {
    return raw.map(tag => tag.trim()).filter(Boolean);
  }
  if (typeof raw === 'string') {
    return raw
      .split(',')
      .map(tag => tag.trim())
      .filter(Boolean);
  }
  return [];
};

const mapPractice = (rec: PracticeRecord): Practice => {
  return {
    id: rec.id,
    title: rec.title,
    types: rec.types || rec.type || 'meditation',
    type: rec.type,
    duration: rec.duration,
    level: normalizePracticeLevel(rec.level || rec.difficulty),
    difficulty: rec.difficulty,
    approach: rec.approach,
    format: rec.format,
    description: rec.description,
    audioUrl: rec.audioUrl,
    videoUrl: rec.videoUrl,
    youtubeUrl: rec.youtubeUrl,
    thumbnailUrl: rec.thumbnailUrl,
    tags: normalizeTags(rec.tags),
    isPublished: rec.isPublished,
    createdAt:
      typeof (rec as unknown as { createdAt?: string }).createdAt === 'string'
        ? (rec as unknown as { createdAt?: string }).createdAt!
        : new Date().toISOString()
  };
};

const mapContent = (rec: ContentRecord): ContentItem => {
  return {
    id: rec.id,
    title: rec.title,
    type: rec.type,
    approach: rec.approach,
    category: rec.category,
    difficulty: rec.difficulty,
    isPublished: rec.isPublished,
    createdAt:
      typeof (rec as unknown as { createdAt?: string }).createdAt === 'string'
        ? (rec as unknown as { createdAt?: string }).createdAt!
        : new Date().toISOString(),
    description: rec.description || undefined,
    thumbnailUrl: rec.thumbnailUrl || undefined,
    tags: normalizeTags(rec.tags)
  };
};

const ADMIN_API_BASE = '/api/admin';

const fetchAdminCollection = async <TItem, TMapped>(
  endpoint: string,
  mapFn: (item: TItem) => TMapped,
  signal?: AbortSignal
): Promise<TMapped[]> => {
  const response = await fetch(`${ADMIN_API_BASE}${endpoint}`, {
    credentials: 'include',
    signal
  });

  if (!response.ok) {
    throw new Error(`Failed to load ${endpoint}`);
  }

  const json = await response.json();
  const data: unknown = Array.isArray(json) ? json : json?.data;
  if (!Array.isArray(data)) {
    return [];
  }

  return (data as TItem[]).map(mapFn);
};

interface UseAdminDashboardDataResult {
  practices: Practice[];
  contentItems: ContentItem[];
  isLoading: boolean;
  error: string | null;
  lastUpdated: string | null;
  refreshAll: () => Promise<void>;
  setPractices: React.Dispatch<React.SetStateAction<Practice[]>>;
  setContentItems: React.Dispatch<React.SetStateAction<ContentItem[]>>;
  markUpdated: () => void;
}

const useAdminDashboardData = (
  admin: AdminUser,
  push: ToastPush
): UseAdminDashboardDataResult => {
  const [practices, setPractices] = useState<Practice[]>([]);
  const [contentItems, setContentItems] = useState<ContentItem[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<string | null>(null);

  const loadAll = useCallback(async (signal?: AbortSignal) => {
    if (!admin) {
      setPractices([]);
      setContentItems([]);
      setIsLoading(false);
      setError(null);
      setLastUpdated(null);
      return;
    }

    setIsLoading(true);
    setError(null);
    try {
      const [practiceResults, contentResults] = await Promise.all([
        fetchAdminCollection<PracticeRecord, Practice>('/practices', mapPractice, signal),
        fetchAdminCollection<ContentRecord, ContentItem>('/content', mapContent, signal)
      ]);
      setPractices(practiceResults);
      setContentItems(contentResults);
      setLastUpdated(new Date().toISOString());
    } catch (err) {
      if (err instanceof DOMException && err.name === 'AbortError') {
        return;
      }
      console.error('Error loading dashboard data:', err);
      const message = err instanceof Error ? err.message : 'Failed to load dashboard data';
      setError(message);
      push({
        type: 'error',
        title: 'Error',
        description: message
      });
    } finally {
      setIsLoading(false);
    }
  }, [admin, push]);

  useEffect(() => {
    const controller = new AbortController();
    loadAll(controller.signal);
    return () => controller.abort();
  }, [loadAll]);

  return {
    practices,
    contentItems,
    isLoading,
    error,
    lastUpdated,
    refreshAll: () => loadAll(),
    setPractices,
    setContentItems,
    markUpdated: () => setLastUpdated(new Date().toISOString())
  };
};

type Tab = 'practices' | 'content';

export const AdminDashboard: React.FC = () => {
  const { admin, adminLogout } = useAdminAuth();
  const { push } = useToast();
  const [tab, setTab] = useState<Tab>('practices');
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  const {
    practices,
    contentItems,
    isLoading,
    error,
    lastUpdated,
    refreshAll,
    setPractices,
    setContentItems,
    markUpdated
  } = useAdminDashboardData(admin, push);

  const [selectedContentType, setSelectedContentType] = useState<string | null>(null);
  type EditablePractice = PracticeRecord | Practice;
  type EditableContent = ContentRecord | ContentItem;
  const [editingPractice, setEditingPractice] = useState<EditablePractice | null>(null);
  const [editingContent, setEditingContent] = useState<EditableContent | null>(null);
  const [activeModal, setActiveModal] = useState<'form' | 'add-practice' | 'add-content' | null>(null);

  const closeForm = useCallback(() => {
    setActiveModal(null);
    setEditingPractice(null);
    setEditingContent(null);
    setSelectedContentType(null);
  }, []);

  useEffect(() => {
    if (!admin) {
      closeForm();
      setMobileMenuOpen(false);
    }
  }, [admin, closeForm]);

  const openAdd = useCallback(() => {
    setSelectedContentType(null);
    setEditingPractice(null);
    setEditingContent(null);
    setActiveModal(tab === 'content' ? 'add-content' : 'add-practice');
  }, [tab]);

  const openAddForm = useCallback(
    (type?: string) => {
      setEditingPractice(null);
      setEditingContent(null);
      if (tab === 'content') {
        setSelectedContentType(type ?? null);
      }
      setActiveModal('form');
    },
    [tab]
  );

  const handleEditPractice = useCallback((practice: EditablePractice) => {
    setTab('practices');
    setEditingPractice(practice);
    setEditingContent(null);
    setActiveModal('form');
  }, []);

  const handleEditContent = useCallback((content: EditableContent) => {
    setTab('content');
    setEditingContent(content);
    setEditingPractice(null);
    setActiveModal('form');
  }, []);

  const handlePracticeSaved = useCallback(
    (saved: PracticeRecord) => {
      const mapped = mapPractice(saved);
      setPractices(prev => {
        const index = prev.findIndex(item => item.id === mapped.id);
        if (index >= 0) {
          const copy = [...prev];
          copy[index] = mapped;
          return copy;
        }
        return [mapped, ...prev];
      });
      markUpdated();
      closeForm();
    },
    [setPractices, markUpdated, closeForm]
  );

  const handleContentSaved = useCallback(
    (saved: ContentRecord) => {
      const mapped = mapContent(saved);
      setContentItems(prev => {
        const index = prev.findIndex(item => item.id === mapped.id);
        if (index >= 0) {
          const copy = [...prev];
          copy[index] = mapped;
          return copy;
        }
        return [mapped, ...prev];
      });
      markUpdated();
      closeForm();
    },
    [setContentItems, markUpdated, closeForm]
  );

  const handleLogout = useCallback(async () => {
    if (window.confirm('Are you sure you want to logout?')) {
      await adminLogout();
      push({ type: 'success', title: 'Success', description: 'Successfully logged out' });
    }
  }, [adminLogout, push]);

  const handleRefresh = useCallback(() => {
    void refreshAll();
  }, [refreshAll]);

  const stats = useMemo(() => {
    return [
      {
        title: 'Total Practices',
        value: practices.length,
        icon: Brain,
        color: 'text-blue-600',
        bgColor: 'bg-blue-50'
      },
      {
        title: 'Content Items',
        value: contentItems.length,
        icon: BookOpen,
        color: 'text-green-600',
        bgColor: 'bg-green-50'
      },
      {
        title: 'Published',
        value: [...practices, ...contentItems].filter(item => item.isPublished).length,
        icon: Shield,
        color: 'text-purple-600',
        bgColor: 'bg-purple-50'
      }
    ];
  }, [practices, contentItems]);

  const hasData = practices.length > 0 || contentItems.length > 0;
  const isInitialLoading = isLoading && !hasData;

  const formattedLastUpdated = useMemo(() => {
    if (!lastUpdated) return null;
    try {
      return new Date(lastUpdated).toLocaleString();
    } catch {
      return lastUpdated;
    }
  }, [lastUpdated]);

  const isFormOpen = activeModal === 'form';
  const isPracticePickerOpen = activeModal === 'add-practice';
  const isContentPickerOpen = activeModal === 'add-content';
  const isEditingPractice = editingPractice !== null;
  const formTitle = isEditingPractice
    ? 'Update Practice'
    : editingContent
      ? 'Update Content'
      : tab === 'practices'
        ? 'Add Practice'
        : 'Add Content';

  return (
    <div className="min-h-screen bg-background">
      {/* Header */}
      <div className="bg-gradient-to-r from-primary/10 to-accent/10 border-b">
        <div className="max-w-7xl mx-auto px-6 py-6">
          <div className="flex justify-between items-center">
            <div className="space-y-1">
              <div className="flex items-center gap-3">
                <Shield className="h-6 w-6 text-primary" />
                <h1 className="text-2xl font-semibold">Admin Dashboard</h1>
              </div>
              <p className="text-muted-foreground">
                Manage practices, content, and monitor platform health
              </p>
            </div>
            
            <div className="flex items-center gap-4">
              {/* Mobile menu toggle */}
              <Button
                variant="ghost"
                size="icon"
                className="md:hidden"
                onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
              >
                {mobileMenuOpen ? <X className="h-5 w-5" /> : <Menu className="h-5 w-5" />}
              </Button>
              
              {/* Desktop menu */}
              <div className="hidden md:flex items-center gap-4">
                <div className="text-right">
                  <Badge variant="secondary" className="bg-primary/10 text-primary">
                    {admin?.role || 'Admin'}
                  </Badge>
                  <p className="text-sm text-muted-foreground mt-1">
                    {admin?.email}
                  </p>
                </div>
                
                <Button
                  variant="outline"
                  onClick={handleLogout}
                  className="text-red-600 border-red-200 hover:bg-red-50 hover:text-red-700"
                >
                  <LogOut className="h-4 w-4 mr-2" />
                  Logout
                </Button>
              </div>
            </div>
          </div>
          
          {/* Mobile menu */}
          {mobileMenuOpen && (
            <div className="md:hidden mt-4 p-4 bg-background rounded-lg border space-y-3">
              <div className="text-center">
                <Badge variant="secondary" className="bg-primary/10 text-primary">
                  {admin?.role || 'Admin'}
                </Badge>
                <p className="text-sm text-muted-foreground mt-1">
                  {admin?.email}
                </p>
              </div>
              <Button
                variant="outline"
                onClick={handleLogout}
                className="w-full text-red-600 border-red-200 hover:bg-red-50 hover:text-red-700"
              >
                <LogOut className="h-4 w-4 mr-2" />
                Logout
              </Button>
            </div>
          )}
        </div>
      </div>

      <div className="max-w-7xl mx-auto p-6 space-y-8" aria-busy={isLoading}>
        {/* Stats Cards */}
        <div className="grid grid-cols-1 gap-4 md:grid-cols-3">
          {isInitialLoading
            ? Array.from({ length: 3 }).map((_, index) => (
                <Card key={`stat-skeleton-${index}`}>
                  <CardContent className="p-6">
                    <div className="flex items-center space-x-4">
                      <Skeleton className="h-12 w-12 rounded-lg" />
                      <div className="flex-1 space-y-2">
                        <Skeleton className="h-4 w-24" />
                        <Skeleton className="h-6 w-16" />
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))
            : stats.map((stat, index) => (
                <Card key={index}>
                  <CardContent className="p-6">
                    <div className="flex items-center space-x-4">
                      <div className={`p-3 rounded-lg ${stat.bgColor}`}>
                        <stat.icon className={`h-6 w-6 ${stat.color}`} />
                      </div>
                      <div>
                        <p className="text-sm font-medium text-muted-foreground">
                          {stat.title}
                        </p>
                        <p className="text-2xl font-bold">
                          {stat.value}
                        </p>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
        </div>

        {error && (
          <div
            className="rounded-md border border-destructive/40 bg-destructive/10 px-4 py-3 text-sm text-destructive"
            role="alert"
            aria-live="assertive"
          >
            <div className="flex items-center gap-2">
              <AlertCircle className="h-4 w-4" />
              <span>{error}</span>
            </div>
            <Button
              variant="outline"
              size="sm"
              onClick={handleRefresh}
              className="mt-3"
            >
              Retry sync
            </Button>
          </div>
        )}

        {/* Main Content Tabs */}
        <Tabs value={tab} onValueChange={(value) => setTab(value as Tab)} className="space-y-6">
          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
            <TabsList className="grid w-full max-w-md grid-cols-2">
              <TabsTrigger value="practices" className="flex items-center gap-2">
                <Brain className="h-4 w-4" />
                Practices
              </TabsTrigger>
              <TabsTrigger value="content" className="flex items-center gap-2">
                <BookOpen className="h-4 w-4" />
                Content
              </TabsTrigger>
            </TabsList>
            <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-3">
              <Button
                variant="outline"
                onClick={handleRefresh}
                disabled={isLoading}
                className="flex items-center gap-2"
              >
                <Loader2 className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />
                Refresh
              </Button>
              <Button onClick={openAdd} className="flex items-center gap-2">
                <Plus className="h-4 w-4" />
                Add {tab === 'practices' ? 'Practice' : 'Content'}
              </Button>
              {formattedLastUpdated && (
                <span className="flex items-center gap-1 text-xs text-muted-foreground" aria-live="polite">
                  <Clock className="h-3 w-3" />
                  Updated {formattedLastUpdated}
                </span>
              )}
            </div>
          </div>

          {isLoading && (
            <div className="flex items-center gap-2 text-sm text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              Syncing latest data…
            </div>
          )}

          <TabsContent value="practices" className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Brain className="h-5 w-5 text-primary" />
                  Practices Management
                </CardTitle>
              </CardHeader>
              <CardContent>
                <PracticesList 
                  embedded 
                  onAdd={openAdd} 
                  onEdit={handleEditPractice} 
                  itemsExternal={practices} 
                  setItemsExternal={setPractices} 
                />
              </CardContent>
            </Card>
          </TabsContent>

          <TabsContent value="content" className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <BookOpen className="h-5 w-5 text-primary" />
                  Content Management
                </CardTitle>
              </CardHeader>
              <CardContent>
                <ContentList 
                  embedded 
                  onAdd={openAdd} 
                  onEdit={handleEditContent} 
                  itemsExternal={contentItems} 
                  setItemsExternal={setContentItems} 
                />
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>

        <Dialog
          open={isFormOpen}
          onOpenChange={(open) => {
            if (!open) {
              closeForm();
            } else {
              setActiveModal('form');
            }
          }}
        >
          <DialogContent className="max-w-5xl w-full p-0">
            <DialogHeader className="px-6 pt-6 pb-4 border-b">
              <div className="flex items-center gap-3">
                {tab === 'practices' ? (
                  <Brain className="h-5 w-5 text-primary" />
                ) : (
                  <BookOpen className="h-5 w-5 text-primary" />
                )}
                <DialogTitle className="text-lg sm:text-xl font-semibold">{formTitle}</DialogTitle>
              </div>
              <DialogDescription>
                {tab === 'practices'
                  ? 'Create or update mindfulness practices and exercises.'
                  : 'Create or update content entries for your wellbeing library.'}
              </DialogDescription>
            </DialogHeader>
            <ScrollArea className="max-h-[75vh]">
              <div className="px-6 py-6">
                {tab === 'practices' ? (
                  <PracticeForm
                    existing={editingPractice ?? undefined}
                    onSaved={handlePracticeSaved}
                    onClose={closeForm}
                  />
                ) : (
                  <ContentForm
                    existing={editingContent ?? undefined}
                    selectedType={selectedContentType}
                    onSaved={handleContentSaved}
                    onClose={closeForm}
                  />
                )}
              </div>
            </ScrollArea>
          </DialogContent>
        </Dialog>
      </div>

      <Dialog
        open={isContentPickerOpen}
        onOpenChange={(open) => {
          if (open) {
            setActiveModal('add-content');
          } else {
            setActiveModal(prev => (prev === 'add-content' ? null : prev));
          }
        }}
      >
        <DialogContent className="max-w-xl w-full space-y-6">
          <DialogHeader className="space-y-2 text-center">
            <div className="flex justify-center">
              <BookOpen className="h-12 w-12 text-primary" />
            </div>
            <DialogTitle className="text-2xl font-semibold">Add New Content</DialogTitle>
            <DialogDescription>Choose the type of content you want to create</DialogDescription>
          </DialogHeader>
          <div className="space-y-3">
            <Button
              className="w-full justify-start h-auto p-4"
              variant="outline"
              onClick={() => openAddForm('article')}
            >
              <div className="flex items-center gap-4">
                <div className="p-2 bg-blue-100 rounded-lg">
                  <FileText className="h-6 w-6 text-blue-600" />
                </div>
                <div className="text-left">
                  <div className="font-medium">Article</div>
                  <div className="text-sm text-muted-foreground">Written content and guides</div>
                </div>
              </div>
            </Button>

            <Button
              className="w-full justify-start h-auto p-4"
              variant="outline"
              onClick={() => openAddForm('audio')}
            >
              <div className="flex items-center gap-4">
                <div className="p-2 bg-green-100 rounded-lg">
                  <Headphones className="h-6 w-6 text-green-600" />
                </div>
                <div className="text-left">
                  <div className="font-medium">Audio</div>
                  <div className="text-sm text-muted-foreground">Podcasts and audio content</div>
                </div>
              </div>
            </Button>

            <Button
              className="w-full justify-start h-auto p-4"
              variant="outline"
              onClick={() => openAddForm('video')}
            >
              <div className="flex items-center gap-4">
                <div className="p-2 bg-purple-100 rounded-lg">
                  <Video className="h-6 w-6 text-purple-600" />
                </div>
                <div className="text-left">
                  <div className="font-medium">Video</div>
                  <div className="text-sm text-muted-foreground">Video tutorials and sessions</div>
                </div>
              </div>
            </Button>

            <Button
              className="w-full justify-start h-auto p-4"
              variant="outline"
              onClick={() => openAddForm('playlist')}
            >
              <div className="flex items-center gap-4">
                <div className="p-2 bg-purple-100 rounded-lg">
                  <Video className="h-6 w-6 text-purple-600" />
                </div>
                <div className="text-left">
                  <div className="font-medium">Playlist</div>
                  <div className="text-sm text-muted-foreground">Curated content collections</div>
                </div>
              </div>
            </Button>

            <Button
              className="w-full justify-start h-auto p-4"
              variant="outline"
              onClick={() => openAddForm('story')}
            >
              <div className="flex items-center gap-4">
                <div className="p-2 bg-orange-100 rounded-lg">
                  <BookMarked className="h-6 w-6 text-orange-600" />
                </div>
                <div className="text-left">
                  <div className="font-medium">Story</div>
                  <div className="text-sm text-muted-foreground">Inspirational stories and experiences</div>
                </div>
              </div>
            </Button>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="ghost" className="w-full sm:w-auto">
                Cancel
              </Button>
            </DialogClose>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog
        open={isPracticePickerOpen}
        onOpenChange={(open) => {
          if (open) {
            setActiveModal('add-practice');
          } else {
            setActiveModal(prev => (prev === 'add-practice' ? null : prev));
          }
        }}
      >
        <DialogContent className="max-w-md w-full space-y-4">
          <DialogHeader className="space-y-2 text-center">
            <div className="flex justify-center">
              <Brain className="h-10 w-10 text-primary" />
            </div>
            <DialogTitle className="text-xl sm:text-2xl font-semibold">Add New Practice</DialogTitle>
            <DialogDescription>Choose the type of practice you want to create</DialogDescription>
          </DialogHeader>
          <div className="space-y-3">
            <Button
              className="w-full justify-start h-auto p-3 sm:p-4"
              variant="outline"
              onClick={() => openAddForm('meditation')}
            >
              <div className="flex items-center gap-3 sm:gap-4">
                <div className="p-1.5 sm:p-2 bg-purple-100 rounded-lg">
                  <Brain className="h-5 w-5 sm:h-6 sm:w-6 text-purple-600" />
                </div>
                <div className="text-left">
                  <div className="font-medium text-sm sm:text-base">Meditation</div>
                  <div className="text-xs sm:text-sm text-muted-foreground">Guided meditation sessions</div>
                </div>
              </div>
            </Button>

            <Button
              className="w-full justify-start h-auto p-3 sm:p-4"
              variant="outline"
              onClick={() => openAddForm('breathing')}
            >
              <div className="flex items-center gap-3 sm:gap-4">
                <div className="p-1.5 sm:p-2 bg-blue-100 rounded-lg">
                  <Mic className="h-5 w-5 sm:h-6 sm:w-6 text-blue-600" />
                </div>
                <div className="text-left">
                  <div className="font-medium text-sm sm:text-base">Breathing Exercise</div>
                  <div className="text-xs sm:text-sm text-muted-foreground">Breathwork and breathing techniques</div>
                </div>
              </div>
            </Button>

            <Button
              className="w-full justify-start h-auto p-3 sm:p-4"
              variant="outline"
              onClick={() => openAddForm('mindfulness')}
            >
              <div className="flex items-center gap-3 sm:gap-4">
                <div className="p-1.5 sm:p-2 bg-green-100 rounded-lg">
                  <Heart className="h-5 w-5 sm:h-6 sm:w-6 text-green-600" />
                </div>
                <div className="text-left">
                  <div className="font-medium text-sm sm:text-base">Mindfulness</div>
                  <div className="text-xs sm:text-sm text-muted-foreground">Mindfulness and awareness practices</div>
                </div>
              </div>
            </Button>

            <Button
              className="w-full justify-start h-auto p-3 sm:p-4"
              variant="outline"
              onClick={() => openAddForm('cbt')}
            >
              <div className="flex items-center gap-3 sm:gap-4">
                <div className="p-1.5 sm:p-2 bg-orange-100 rounded-lg">
                  <BookOpen className="h-5 w-5 sm:h-6 sm:w-6 text-orange-600" />
                </div>
                <div className="text-left">
                  <div className="font-medium text-sm sm:text-base">CBT Exercise</div>
                  <div className="text-xs sm:text-sm text-muted-foreground">Cognitive behavioral therapy techniques</div>
                </div>
              </div>
            </Button>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="ghost" className="w-full sm:w-auto">
                Cancel
              </Button>
            </DialogClose>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
};

export default AdminDashboard;


Practice form


import { Loader2 } from 'lucide-react';
import React, { useState, useEffect, useRef } from 'react';

import { Button } from '../components/ui/button';
import { Input } from '../components/ui/input';
import { Label } from '../components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/select';
import { Switch } from '../components/ui/switch';
import { Textarea } from '../components/ui/textarea';
import { useToast } from '../contexts/ToastContext';

export interface PracticeRecord {
  id: string;
  title: string;
  type: 'meditation' | 'breathing' | 'yoga' | 'sleep';
  format?: 'Audio' | 'Video' | 'Audio/Video';
  types?: string;
  duration: number;
  level?: 'Beginner' | 'Intermediate' | 'Advanced';
  difficulty?: string;
  approach: 'Western' | 'Eastern' | 'Hybrid' | 'All';
  description?: string;
  audioUrl?: string;
  videoUrl?: string;
  youtubeUrl?: string;
  thumbnailUrl?: string;
  tags?: string[];
  isPublished: boolean;
  createdAt?: string;
  updatedAt?: string;
}

interface PracticeFormProps {
  existing?: PracticeRecord;
  onSaved: (practice: PracticeRecord) => void;
  onClose: () => void;
}

export const PracticeForm: React.FC<PracticeFormProps> = ({ existing, onSaved, onClose }) => {
  const { push } = useToast();
  const [loading, setLoading] = useState(false);
  const [uploaded, setUploaded] = useState({ audio: false, video: false, thumbnail: false });
  const [fileNames, setFileNames] = useState<{ audio?: string; video?: string; thumbnail?: string }>({});
  const [metaLoading, setMetaLoading] = useState(false);
  const [formData, setFormData] = useState<Partial<PracticeRecord>>({
    title: '',
    type: 'meditation',
    duration: 5,
    level: 'Beginner',
    approach: 'All',
    format: 'Audio',
    description: '',
    audioUrl: '',
    videoUrl: '',
    youtubeUrl: '',
    thumbnailUrl: '',
    tags: [],
    isPublished: false,
  });

  useEffect(() => {
    if (existing) {
      // Normalize existing.tags: backend may return comma string
      let normalizedTags: string[] | undefined = existing.tags;
      if (normalizedTags && !Array.isArray(normalizedTags)) {
        if (typeof (normalizedTags as unknown) === 'string') {
          const raw = normalizedTags as unknown as string;
          normalizedTags = raw.split(',').map(t => t.trim()).filter(t => t.length > 0);
        } else {
          normalizedTags = [];
        }
      }
      setFormData({ ...existing, tags: normalizedTags || [] });
    }
  }, [existing]);

  const handleInputChange = (field: keyof PracticeRecord, value: string | number | boolean | string[]) => {
    // If type changes to sleep, enforce Audio format
    if (field === 'type' && value === 'sleep') {
      setFormData(prev => ({ ...prev, type: value as PracticeRecord['type'], format: 'Audio' }));
      return;
    }
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  const handleTagsChange = (tagsString: string) => {
    const tags = tagsString.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
    handleInputChange('tags', tags);
  };

  function extractYouTubeId(raw?: string) {
    if (!raw) return '';
    const val = raw.trim();
    if (/^[a-zA-Z0-9_-]{11}$/.test(val)) return val;
    try {
      const u = new URL(val);
      if (u.hostname.includes('youtu.be')) return u.pathname.slice(1).split(/[?&#]/)[0];
      const v = u.searchParams.get('v');
      if (v) return v;
      if (u.pathname.startsWith('/embed/')) return u.pathname.split('/')[2];
      if (u.pathname.startsWith('/shorts/')) return u.pathname.split('/')[2];
  } catch (_) { /* ignore parse */ }
    return val;
  }

  // Fetch full YouTube metadata (title, description, thumbnail, duration)
  const fetchYouTubeFull = async (id: string, force = false) => {
    console.log('fetchYouTubeFull called with id:', id, 'force:', force);
    setMetaLoading(true);
    try {
      const resp = await fetch(`/api/admin/media/metadata?type=youtube&value=${encodeURIComponent(id)}`, { credentials: 'include' });
      console.log('Metadata response status:', resp.status);
      if (!resp.ok) {
        let msg = `Metadata request failed (${resp.status})`;
        try {
          const errJson = await resp.json();
          if (errJson?.error) msg = errJson.error;
        } catch { /* ignore parse */ }
        console.warn('YouTube metadata fetch failed:', msg);
        push({ type: 'error', title: 'YouTube Metadata', description: msg });
        return;
      }
      const json = await resp.json();
      console.log('Metadata response:', json);
      if (!json.success) {
        push({ type: 'error', title: 'YouTube Metadata', description: json.error || 'Failed to fetch video data' });
        return;
      }
      console.log('Setting form data with duration:', json.durationMinutes, 'current duration:', formData.duration);
      setFormData(prev => ({
        ...prev,
        youtubeUrl: id,
        title: prev.title?.trim() ? prev.title : (json.title || prev.title),
        description: prev.description?.trim() ? prev.description : (json.description || prev.description),
        thumbnailUrl: prev.thumbnailUrl?.trim() ? prev.thumbnailUrl : (json.thumbnail || prev.thumbnailUrl),
        duration: (force || !prev.duration || prev.duration <= 1 || prev.duration === 5) && json.durationMinutes
          ? json.durationMinutes
          : prev.duration
      }));
    } catch (e) {
      console.error('YouTube metadata exception', e);
      push({ type: 'error', title: 'YouTube Metadata', description: 'Unexpected error fetching metadata' });
    } finally {
      setMetaLoading(false);
    }
  };

  // Debounced auto-fetch when youtubeUrl changes
  const ytDebounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const lastFetchedId = useRef<string>('');
  useEffect(() => {
    const raw = formData.youtubeUrl?.trim();
    console.log('YouTube URL changed:', raw);
    if (!raw) return; // nothing to do
    if (ytDebounceRef.current) clearTimeout(ytDebounceRef.current);
    ytDebounceRef.current = setTimeout(() => {
      const id = extractYouTubeId(raw);
      console.log('Extracted YouTube ID:', id);
      if (!id) return;
      // Normalize stored ID immediately if different
      if (id !== formData.youtubeUrl) {
        setFormData(prev => ({ ...prev, youtubeUrl: id }));
      }
      if (lastFetchedId.current === id) return; // avoid duplicate fetch
      lastFetchedId.current = id;
      fetchYouTubeFull(id);
    }, 500);
    return () => { if (ytDebounceRef.current) clearTimeout(ytDebounceRef.current); };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formData.youtubeUrl]);

  const fetchFileMetadata = async (fileUrl: string) => {
    try {
      const resp = await fetch(`/api/admin/media/metadata?type=file&value=${encodeURIComponent(fileUrl)}`, { credentials: 'include' });
      if (!resp.ok) return null;
      const json = await resp.json();
      return json.success ? json : null;
    } catch (e) {
      console.error('File metadata fetch error:', e);
      return null;
    }
  };

  const uploadFile = async (file: File, type: 'media' | 'thumbnail') => {
    const form = new FormData();
    form.append('file', file);
    const resp = await fetch(`/api/admin/upload/${type}`, { method: 'POST', body: form, credentials: 'include' });
    if (!resp.ok) throw new Error('Upload failed');
    const data = await resp.json();
    return data.url as string;
  };

  const fetchYouTubeDuration = async (id: string) => {
    try {
      const resp = await fetch(`/api/admin/youtube/metadata/${id}`, { credentials: 'include' });
      if (!resp.ok) return; // silent
      const json = await resp.json();
      if (json.success && json.durationMinutes && (!formData.duration || !existing)) {
        setFormData(prev => ({ ...prev, duration: json.durationMinutes }));
      }
  } catch (_) { /* ignore metadata fetch */ }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.title?.trim()) {
      push({ type: 'error', title: 'Validation Error', description: 'Title is required' });
      return;
    }

    if (!formData.description || !formData.description.trim()) {
      push({ type: 'error', title: 'Validation Error', description: 'Description is required' });
      return;
    }

    if (!formData.thumbnailUrl || !formData.thumbnailUrl.trim()) {
      push({ type: 'error', title: 'Validation Error', description: 'Thumbnail is required (URL or uploaded image)' });
      return;
    }

    // Media requirements
    if (formData.format === 'Audio') {
      const hasAudio = (formData.audioUrl && formData.audioUrl.trim()) || uploaded.audio;
      if (!hasAudio) {
        push({ type: 'error', title: 'Validation Error', description: 'Provide an Audio URL or upload an audio file' });
        return;
      }
    }
    if (formData.format === 'Video') {
      const hasVideo = (formData.videoUrl && formData.videoUrl.trim()) || (formData.youtubeUrl && formData.youtubeUrl.trim()) || uploaded.video;
      if (!hasVideo) {
        push({ type: 'error', title: 'Validation Error', description: 'Provide a Video URL, YouTube URL, or upload a video file' });
        return;
      }
    }

    if (!formData.duration || formData.duration <= 0) {
      push({ type: 'error', title: 'Validation Error', description: 'Duration must be greater than 0' });
      return;
    }

    setLoading(true);
    try {
      // Normalize YouTube ID
      if (formData.youtubeUrl) {
        const id = extractYouTubeId(formData.youtubeUrl);
        if (id && id !== formData.youtubeUrl) {
          setFormData(prev => ({ ...prev, youtubeUrl: id }));
          await fetchYouTubeDuration(id);
        }
      }

      // Perform pending uploads: detect temp placeholders 'uploaded-*'
  const updated: Record<string, unknown> = { ...formData };
      const uploadTasks: Promise<void>[] = [];
      const audioInput = document.getElementById('audioUpload') as HTMLInputElement | null;
      const videoInput = document.getElementById('videoUpload') as HTMLInputElement | null;
      const thumbInput = document.getElementById('thumbnailUpload') as HTMLInputElement | null;
      if (audioInput?.files?.[0] && formData.format === 'Audio') {
        uploadTasks.push(uploadFile(audioInput.files[0], 'media').then(url => { updated.audioUrl = url; }));
      }
      if (videoInput?.files?.[0] && formData.format === 'Video') {
        uploadTasks.push(uploadFile(videoInput.files[0], 'media').then(url => { updated.videoUrl = url; }));
      }
      if (thumbInput?.files?.[0]) {
        uploadTasks.push(uploadFile(thumbInput.files[0], 'thumbnail').then(url => { updated.thumbnailUrl = url; }));
      }
      if (uploadTasks.length) await Promise.all(uploadTasks);

      // Fetch metadata for uploaded media files
      if (updated.audioUrl) {
        const meta = await fetchFileMetadata(updated.audioUrl as string);
        if (meta?.durationMinutes && (!updated.duration || updated.duration === 5)) {
          updated.duration = meta.durationMinutes;
        }
        if (meta?.title && !updated.title) {
          updated.title = meta.title;
        }
      }
      if (updated.videoUrl) {
        const meta = await fetchFileMetadata(updated.videoUrl as string);
        if (meta?.durationMinutes && (!updated.duration || updated.duration === 5)) {
          updated.duration = meta.durationMinutes;
        }
        if (meta?.title && !updated.title) {
          updated.title = meta.title;
        }
      }

      const url = existing ? `/api/admin/practices/${existing.id}` : '/api/admin/practices';
      const method = existing ? 'PUT' : 'POST';
      
      // Build payload mapping level -> difficulty and serializing tags
      interface PracticePayload extends Omit<PracticeRecord, 'id' | 'tags' | 'level'> {
        level?: string;
        tags?: string | string[];
        difficulty?: string;
      }
      const payload: PracticePayload = {
        ...(formData as PracticePayload),
        difficulty: formData.difficulty || formData.level,
        tags: Array.isArray(formData.tags) ? formData.tags.join(',') : formData.tags,
      };
      // Remove level to avoid confusion backend side (we keep difficulty)
      delete payload.level;

      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ ...payload, ...updated }),
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error(`Failed to ${existing ? 'update' : 'create'} practice`);
      }

  const savedPractice = await response.json();
      onSaved(savedPractice);
      push({ 
        type: 'success', 
        title: 'Success', 
        description: `Practice ${existing ? 'updated' : 'created'} successfully` 
      });
    } catch (error) {
      console.error('Practice save error:', error);
      push({ 
        type: 'error', 
        title: 'Error', 
        description: error instanceof Error ? error.message : 'Failed to save practice' 
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="title">Title *</Label>
          <Input
            id="title"
            value={formData.title || ''}
            onChange={(e) => handleInputChange('title', e.target.value)}
            placeholder="Practice title"
            required
          />
        </div>

        <div className="space-y-2">
          <Label htmlFor="type">Type</Label>
          <Select
            value={formData.type || 'Meditation'}
            onValueChange={(value) => handleInputChange('type', value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="meditation">Meditation</SelectItem>
              <SelectItem value="breathing">Breathing</SelectItem>
              <SelectItem value="yoga">Yoga</SelectItem>
              <SelectItem value="sleep">Sleep</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="space-y-2">
          <Label htmlFor="duration">Duration (minutes) *</Label>
          <Input
            id="duration"
            type="number"
            value={formData.duration || 5}
            onChange={(e) => handleInputChange('duration', parseInt(e.target.value) || 5)}
            placeholder="Duration in minutes"
            min="1"
            required
          />
        </div>

        <div className="space-y-2">
          <Label htmlFor="level">Level</Label>
          <Select
            value={formData.level || 'Beginner'}
            onValueChange={(value) => handleInputChange('level', value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select level" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="Beginner">Beginner</SelectItem>
              <SelectItem value="Intermediate">Intermediate</SelectItem>
              <SelectItem value="Advanced">Advanced</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="space-y-2">
          <Label htmlFor="approach">Approach</Label>
          <Select
            value={formData.approach || 'All'}
            onValueChange={(value) => handleInputChange('approach', value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select approach" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="All">All Approaches</SelectItem>
              <SelectItem value="Western">Western</SelectItem>
              <SelectItem value="Eastern">Eastern</SelectItem>
              <SelectItem value="Hybrid">Hybrid</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="space-y-2">
          <Label htmlFor="format">Format</Label>
          <Select
            value={formData.format || 'Audio'}
            onValueChange={(value) => handleInputChange('format', value)}
            disabled={formData.type === 'sleep'}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select format" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="Audio">Audio</SelectItem>
              <SelectItem value="Video">Video</SelectItem>
            </SelectContent>
          </Select>
          {formData.type === 'sleep' && (
            <p className="text-xs text-muted-foreground">Sleep practices are limited to audio format.</p>
          )}
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="description">Description *</Label>
        <Textarea
          id="description"
          value={formData.description || ''}
          onChange={(e) => handleInputChange('description', e.target.value)}
          placeholder="Brief description of the practice"
          rows={3}
        />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {formData.format === 'Audio' && (
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="audioUrl">Audio URL</Label>
              <Input
                id="audioUrl"
                value={formData.audioUrl || ''}
                onChange={(e) => handleInputChange('audioUrl', e.target.value)}
                placeholder="Direct link to audio file"
                type="url"
                disabled={uploaded.audio}
              />
              {uploaded.audio && (
                <div className="flex items-center justify-between text-xs mt-1">
                  <span className="text-green-600">Selected file: {fileNames.audio}</span>
                  <button
                    type="button"
                    className="text-red-500 hover:underline"
                    onClick={() => {
                      setUploaded(prev => ({ ...prev, audio: false }));
                      setFileNames(prev => ({ ...prev, audio: undefined }));
                      handleInputChange('audioUrl', '');
                    }}
                  >Remove</button>
                </div>
              )}
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="audioUpload">Or Upload Audio File</Label>
              <Input
                id="audioUpload"
                type="file"
                accept="audio/*"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) {
                    handleInputChange('audioUrl', `uploaded-audio-${file.name}`);
                    setUploaded(prev => ({ ...prev, audio: true }));
                    setFileNames(prev => ({ ...prev, audio: file.name }));
                    if (!formData.title) {
                      setFormData(prev => ({ ...prev, title: file.name.replace(/\.[^.]+$/, '').replace(/[-_]/g,' ') }));
                    }
                  }
                }}
                className="file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary file:text-primary-foreground hover:file:bg-primary/80"
              />
              <p className="text-xs text-muted-foreground">
                Upload an audio file from your local machine
              </p>
            </div>
          </div>
        )}

        {formData.format === 'Video' && (
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="videoUrl">Video URL</Label>
              <Input
                id="videoUrl"
                value={formData.videoUrl || ''}
                onChange={(e) => handleInputChange('videoUrl', e.target.value)}
                placeholder="Direct link to video file"
                type="url"
                disabled={uploaded.video}
              />
              {uploaded.video && (
                <div className="flex items-center justify-between text-xs mt-1">
                  <span className="text-green-600">Selected file: {fileNames.video}</span>
                  <button
                    type="button"
                    className="text-red-500 hover:underline"
                    onClick={() => {
                      setUploaded(prev => ({ ...prev, video: false }));
                      setFileNames(prev => ({ ...prev, video: undefined }));
                      handleInputChange('videoUrl', '');
                    }}
                  >Remove</button>
                </div>
              )}
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="videoUpload">Or Upload Video File</Label>
              <Input
                id="videoUpload"
                type="file"
                accept="video/*"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) {
                    handleInputChange('videoUrl', `uploaded-video-${file.name}`);
                    setUploaded(prev => ({ ...prev, video: true }));
                    setFileNames(prev => ({ ...prev, video: file.name }));
                    if (!formData.title) {
                      setFormData(prev => ({ ...prev, title: file.name.replace(/\.[^.]+$/, '').replace(/[-_]/g,' ') }));
                    }
                  }
                }}
                className="file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary file:text-primary-foreground hover:file:bg-primary/80"
              />
              <p className="text-xs text-muted-foreground">
                Upload a video file from your local machine
              </p>
            </div>
          </div>
        )}

        <div className="space-y-2">
          <Label htmlFor="youtubeUrl" className="flex items-center gap-2">
            YouTube URL (Optional)
            {metaLoading && <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />}
          </Label>
          <div className="relative">
            <Input
              id="youtubeUrl"
              className={metaLoading ? 'pr-8' : ''}
              value={formData.youtubeUrl || ''}
              onChange={(e) => handleInputChange('youtubeUrl', e.target.value)}
              placeholder="Paste a YouTube link to auto-fill"
              type="url"
            />
            {metaLoading && (
              <Loader2 className="h-4 w-4 animate-spin absolute right-2 top-1/2 -translate-y-1/2 text-muted-foreground" />
            )}
          </div>
          <p className="text-xs text-muted-foreground">
            {metaLoading ? 'Fetching metadata…' : 'Title, description, thumbnail & duration will auto-fill.'}
          </p>
        </div>

        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="thumbnailUrl">Thumbnail URL *</Label>
            <Input
              id="thumbnailUrl"
              value={formData.thumbnailUrl || ''}
              onChange={(e) => handleInputChange('thumbnailUrl', e.target.value)}
              placeholder="URL to thumbnail image"
              type="url"
              disabled={uploaded.thumbnail}
            />
            {uploaded.thumbnail && (
              <div className="flex items-center justify-between text-xs mt-1">
                <span className="text-green-600">Selected file: {fileNames.thumbnail}</span>
                <button
                  type="button"
                  className="text-red-500 hover:underline"
                  onClick={() => {
                    setUploaded(prev => ({ ...prev, thumbnail: false }));
                    setFileNames(prev => ({ ...prev, thumbnail: undefined }));
                    handleInputChange('thumbnailUrl', '');
                  }}
                >Remove</button>
              </div>
            )}
          </div>
          <div className="space-y-2">
            <Label htmlFor="thumbnailUpload">Or Upload Thumbnail *</Label>
            <Input
              id="thumbnailUpload"
              type="file"
              accept="image/*"
              onChange={(e) => {
                const file = e.target.files?.[0];
                if (file) {
                  handleInputChange('thumbnailUrl', `uploaded-image-${file.name}`);
                  setUploaded(prev => ({ ...prev, thumbnail: true }));
                  setFileNames(prev => ({ ...prev, thumbnail: file.name }));
                }
              }}
              className="file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary file:text-primary-foreground hover:file:bg-primary/80"
            />
            <p className="text-xs text-muted-foreground">Provide an image URL or upload a local image file.</p>
          </div>
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="tags">Tags (comma-separated)</Label>
        <Input
          id="tags"
          value={Array.isArray(formData.tags) ? formData.tags.join(', ') : ''}
          onChange={(e) => handleTagsChange(e.target.value)}
          placeholder="anxiety, stress, relaxation"
        />
      </div>

      <div className="flex items-center space-x-2">
        <Switch
          id="isPublished"
          checked={formData.isPublished || false}
          onCheckedChange={(checked) => handleInputChange('isPublished', checked)}
        />
        <Label htmlFor="isPublished">Published</Label>
      </div>

      <div className="flex justify-end space-x-2 pt-4">
        <Button type="button" variant="outline" onClick={onClose}>
          Cancel
        </Button>
        <Button type="submit" disabled={loading}>
          {loading ? 'Saving...' : existing ? 'Update' : 'Create'}
        </Button>
      </div>
    </form>
  );
};




Content Form



import { Loader2 } from 'lucide-react';
import React, { useState, useEffect, useRef } from 'react';

import { Button } from '../components/ui/button';
import { Input } from '../components/ui/input';
import { Label } from '../components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../components/ui/select';
import { Switch } from '../components/ui/switch';
import { Textarea } from '../components/ui/textarea';
import { useToast } from '../contexts/ToastContext';

export interface ContentRecord {
  id: string;
  title: string;
  type: 'video' | 'audio' | 'article' | 'playlist' | 'story';
  approach: 'western' | 'eastern' | 'hybrid' | 'all';
  category?: string;
  difficulty?: 'Beginner' | 'Intermediate' | 'Advanced';
  description?: string;
  content?: string;
  url?: string;
  youtubeUrl?: string;
  thumbnailUrl?: string;
  duration?: number;
  tags?: string[];
  isPublished: boolean;
  createdAt?: string;
  updatedAt?: string;
}

interface ContentFormProps {
  existing?: ContentRecord;
  selectedType?: string | null;
  onSaved: (content: ContentRecord) => void;
  onClose: () => void;
}

export const ContentForm: React.FC<ContentFormProps> = ({ existing, selectedType, onSaved, onClose }) => {
  const { push } = useToast();
  const [loading, setLoading] = useState(false);
  const [uploaded, setUploaded] = useState({ media: false, thumbnail: false });
  const [fileNames, setFileNames] = useState<{ media?: string; thumbnail?: string }>({});
  const [metaLoading, setMetaLoading] = useState(false);
  const [formData, setFormData] = useState<Partial<ContentRecord>>({
    title: '',
    type: 'article',
    approach: 'all',
    category: '',
    difficulty: 'Beginner',
    description: '',
    content: '',
    url: '',
    youtubeUrl: '',
    thumbnailUrl: '',
    duration: 0,
    tags: [],
    isPublished: false,
  });

  useEffect(() => {
    if (existing) {
      // Normalize tags: backend returns comma-separated string
      let normalizedTags: string[] | undefined = existing.tags as unknown as string[] | undefined;
      if (normalizedTags && !Array.isArray(normalizedTags)) {
        if (typeof (normalizedTags as unknown) === 'string') {
          const raw = normalizedTags as unknown as string;
          normalizedTags = raw.split(',')
            .map(t => t.trim())
            .filter(t => t.length > 0);
        } else {
          normalizedTags = [];
        }
      }
      setFormData({ ...existing, tags: normalizedTags || [] });
    } else if (selectedType) {
      setFormData(prev => ({
        ...prev,
        type: selectedType as ContentRecord['type']
      }));
    }
  }, [existing, selectedType]);

  type FieldValue = string | number | boolean | string[] | undefined;
  const handleInputChange = (field: keyof ContentRecord, value: FieldValue) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  const handleTagsChange = (tagsString: string) => {
    const tags = tagsString.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
    handleInputChange('tags', tags);
  };

  function extractYouTubeId(raw?: string) {
    if (!raw) return '';
    const val = raw.trim();
    if (/^[a-zA-Z0-9_-]{11}$/.test(val)) return val;
    try {
      const u = new URL(val);
      if (u.hostname.includes('youtu.be')) return u.pathname.slice(1).split(/[?&#]/)[0];
      const v = u.searchParams.get('v');
      if (v) return v;
      if (u.pathname.startsWith('/embed/')) return u.pathname.split('/')[2];
      if (u.pathname.startsWith('/shorts/')) return u.pathname.split('/')[2];
    } catch (_) { /* ignore */ }
    return val;
  }

  const fetchYouTubeFull = async (id: string, force = false) => {
    console.log('ContentForm fetchYouTubeFull called with id:', id, 'force:', force);
    setMetaLoading(true);
    try {
      const resp = await fetch(`/api/admin/media/metadata?type=youtube&value=${encodeURIComponent(id)}`, { credentials: 'include' });
      console.log('ContentForm metadata response status:', resp.status);
      if (!resp.ok) {
        let msg = `Metadata request failed (${resp.status})`;
        try {
          const errJson = await resp.json();
          if (errJson?.error) msg = errJson.error;
        } catch { /* ignore parse */ }
        console.warn('YouTube metadata fetch failed:', msg);
        push({ type: 'error', title: 'YouTube Metadata', description: msg });
        return;
      }
      const json = await resp.json();
      console.log('ContentForm metadata response:', json);
      if (!json.success) {
        push({ type: 'error', title: 'YouTube Metadata', description: json.error || 'Failed to fetch video data' });
        return;
      }
      console.log('ContentForm setting form data with duration:', json.durationMinutes, 'current duration:', formData.duration);
      setFormData(prev => ({
        ...prev,
        youtubeUrl: id,
        title: prev.title?.trim() ? prev.title : (json.title || prev.title),
        description: prev.description?.trim() ? prev.description : (json.description || prev.description),
        thumbnailUrl: prev.thumbnailUrl?.trim() ? prev.thumbnailUrl : (json.thumbnail || prev.thumbnailUrl),
        duration: (force || !prev.duration || prev.duration <= 1 || prev.duration === 5) && json.durationMinutes
          ? json.durationMinutes
          : prev.duration
      }));
    } catch (e) {
      console.error('YouTube metadata exception', e);
      push({ type: 'error', title: 'YouTube Metadata', description: 'Unexpected error fetching metadata' });
    } finally {
      setMetaLoading(false);
    }
  };

  // Debounced auto-fetch when youtubeUrl changes
  const ytDebounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const lastFetchedId = useRef<string>('');
  useEffect(() => {
    const raw = formData.youtubeUrl?.trim();
    console.log('ContentForm YouTube URL changed:', raw);
    if (!raw) return;
    if (ytDebounceRef.current) clearTimeout(ytDebounceRef.current);
    ytDebounceRef.current = setTimeout(() => {
      const id = extractYouTubeId(raw);
      console.log('ContentForm extracted YouTube ID:', id);
      if (!id) return;
      if (id !== formData.youtubeUrl) {
        setFormData(prev => ({ ...prev, youtubeUrl: id }));
      }
      if (lastFetchedId.current === id) return;
      lastFetchedId.current = id;
      fetchYouTubeFull(id);
    }, 500);
    return () => { if (ytDebounceRef.current) clearTimeout(ytDebounceRef.current); };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formData.youtubeUrl]);

  const uploadFile = async (file: File, type: 'media' | 'thumbnail') => {
    const form = new FormData();
    form.append('file', file);
    const resp = await fetch(`/api/admin/upload/${type}`, { method: 'POST', body: form, credentials: 'include' });
    if (!resp.ok) throw new Error('Upload failed');
    const data = await resp.json();
    return data.url as string;
  };

  const fetchFileMetadata = async (fileUrl: string) => {
    try {
      const resp = await fetch(`/api/admin/media/metadata?type=file&value=${encodeURIComponent(fileUrl)}`, { credentials: 'include' });
      if (!resp.ok) return null;
      const json = await resp.json();
      return json.success ? json : null;
    } catch (e) {
      console.error('File metadata fetch error:', e);
      return null;
    }
  };

  const fetchYouTubeDuration = async (id: string) => {
    try {
      const resp = await fetch(`/api/admin/youtube/metadata/${id}`, { credentials: 'include' });
      if (!resp.ok) return;
      const json = await resp.json();
      if (json.success && json.durationMinutes && (!formData.duration || !existing)) {
        setFormData(prev => ({ ...prev, duration: json.durationMinutes }));
      }
    } catch (_) { /* ignore */ }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!formData.title?.trim()) {
      push({ type: 'error', title: 'Validation Error', description: 'Title is required' });
      return;
    }
    if (!formData.description || !formData.description.trim()) {
      push({ type: 'error', title: 'Validation Error', description: 'Description is required' });
      return;
    }
    if (!formData.thumbnailUrl || !formData.thumbnailUrl.trim()) {
      push({ type: 'error', title: 'Validation Error', description: 'Thumbnail is required (URL or uploaded image)' });
      return;
    }
    // Media validation for video/audio content
    if (formData.type === 'video') {
      const hasVideo = (formData.url && formData.url.trim()) || (formData.youtubeUrl && formData.youtubeUrl.trim()) || uploaded.media;
      if (!hasVideo) {
        push({ type: 'error', title: 'Validation Error', description: 'Provide a Video URL, YouTube URL, or upload a video file' });
        return;
      }
    }
    if (formData.type === 'audio') {
      const hasAudio = (formData.url && formData.url.trim()) || uploaded.media;
      if (!hasAudio) {
        push({ type: 'error', title: 'Validation Error', description: 'Audio URL or uploaded audio file is required' });
        return;
      }
    }

    setLoading(true);
    try {
      // Normalize YouTube
      if (formData.youtubeUrl) {
        const id = extractYouTubeId(formData.youtubeUrl);
        if (id && id !== formData.youtubeUrl) {
          setFormData(prev => ({ ...prev, youtubeUrl: id }));
          await fetchYouTubeDuration(id);
        }
      }

      // Uploads
      const updated: Record<string, unknown> = { ...formData };
      const mediaInput = document.getElementById('fileUpload') as HTMLInputElement | null;
      const thumbInput = document.getElementById('thumbnailUpload') as HTMLInputElement | null;
      const tasks: Promise<void>[] = [];
      if (mediaInput?.files?.[0] && (formData.type === 'video' || formData.type === 'audio')) {
        tasks.push(uploadFile(mediaInput.files[0], 'media').then(url => { updated.url = url; }));
      }
      if (thumbInput?.files?.[0]) {
        tasks.push(uploadFile(thumbInput.files[0], 'thumbnail').then(url => { updated.thumbnailUrl = url; }));
      }
      if (tasks.length) await Promise.all(tasks);

      // Fetch metadata for uploaded media files
      if (updated.url && (formData.type === 'video' || formData.type === 'audio')) {
        const meta = await fetchFileMetadata(updated.url as string);
        if (meta?.durationMinutes && (!updated.duration || updated.duration === 5)) {
          updated.duration = meta.durationMinutes;
        }
        if (meta?.title && !updated.title) {
          updated.title = meta.title;
        }
      }

      const url = existing ? `/api/admin/content/${existing.id}` : '/api/admin/content';
      const method = existing ? 'PUT' : 'POST';
      
      // Build payload matching backend requirements
      const mediaContent = (() => {
        if (formData.type === 'video') {
          return formData.url || formData.youtubeUrl || '';
        }
        if (formData.type === 'audio') {
          return formData.url || '';
        }
        return formData.content || formData.url || formData.description || '';
      })();

      const payload = {
        title: formData.title,
        type: formData.type,
        category: formData.category || 'General',
        approach: formData.approach || 'all',
        content: mediaContent,
        description: formData.description,
        youtubeUrl: updated.youtubeUrl || formData.youtubeUrl,
        thumbnailUrl: updated.thumbnailUrl || formData.thumbnailUrl,
        duration: formData.duration && formData.duration > 0 ? formData.duration : (updated.duration as number | undefined),
        difficulty: formData.difficulty,
        tags: Array.isArray(formData.tags) ? formData.tags : [],
        isPublished: formData.isPublished || false
      };

      const response = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...payload, ...updated }),
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error(`Failed to ${existing ? 'update' : 'create'} content`);
      }

  const savedContent = await response.json();
  const record = savedContent.success ? savedContent.data : savedContent; // handle old/new
  onSaved(record);
      push({ 
        type: 'success', 
        title: 'Success', 
        description: `Content ${existing ? 'updated' : 'created'} successfully` 
      });
    } catch (error) {
      console.error('Content save error:', error);
      push({ 
        type: 'error', 
        title: 'Error', 
        description: error instanceof Error ? error.message : 'Failed to save content' 
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="title">Title *</Label>
          <Input
            id="title"
            value={formData.title || ''}
            onChange={(e) => handleInputChange('title', e.target.value)}
            placeholder="Content title"
            required
          />
        </div>

        {/* Only show type selection if not pre-selected */}
        {!selectedType && (
          <div className="space-y-2">
            <Label htmlFor="type">Type</Label>
            <Select
              value={formData.type || 'article'}
              onValueChange={(value) => handleInputChange('type', value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="article">Article</SelectItem>
                <SelectItem value="video">Video</SelectItem>
                <SelectItem value="audio">Audio</SelectItem>
                <SelectItem value="playlist">Playlist</SelectItem>
                <SelectItem value="story">Story</SelectItem>
              </SelectContent>
            </Select>
          </div>
        )}

        {/* Show selected type as read-only if pre-selected */}
        {selectedType && (
          <div className="space-y-2">
            <Label>Content Type</Label>
            <div className="flex items-center gap-2 p-2 bg-muted rounded-md">
              <span className="text-sm font-medium capitalize">{selectedType}</span>
            </div>
          </div>
        )}

        <div className="space-y-2">
          <Label htmlFor="approach">Approach</Label>
          <Select
            value={formData.approach || 'all'}
            onValueChange={(value) => handleInputChange('approach', value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select approach" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Approaches</SelectItem>
              <SelectItem value="western">Western</SelectItem>
              <SelectItem value="eastern">Eastern</SelectItem>
              <SelectItem value="hybrid">Hybrid</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="space-y-2">
          <Label htmlFor="category">Category</Label>
          <Select
            value={formData.category || ''}
            onValueChange={(value) => handleInputChange('category', value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select category" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="Mindfulness">Mindfulness</SelectItem>
              <SelectItem value="Anxiety">Anxiety</SelectItem>
              <SelectItem value="Stress Management">Stress Management</SelectItem>
              <SelectItem value="Relaxation">Relaxation</SelectItem>
              <SelectItem value="Emotional Intelligence">Emotional Intelligence</SelectItem>
              <SelectItem value="Series">Series</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="space-y-2">
          <Label htmlFor="difficulty">Difficulty</Label>
          <Select
            value={formData.difficulty || 'Beginner'}
            onValueChange={(value) => handleInputChange('difficulty', value)}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select difficulty" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="Beginner">Beginner</SelectItem>
              <SelectItem value="Intermediate">Intermediate</SelectItem>
              <SelectItem value="Advanced">Advanced</SelectItem>
            </SelectContent>
          </Select>
        </div>

        {(formData.type === 'video' || formData.type === 'audio' || formData.type === 'playlist') && (
          <div className="space-y-2">
            <Label htmlFor="duration">Duration (minutes)</Label>
            <Input
              id="duration"
              type="number"
              value={formData.duration || 0}
              onChange={(e) => handleInputChange('duration', parseInt(e.target.value) || 0)}
              placeholder="Duration in minutes"
              min="0"
            />
          </div>
        )}
      </div>

      <div className="space-y-2">
        <Label htmlFor="description">Description *</Label>
        <Textarea
          id="description"
          value={formData.description || ''}
          onChange={(e) => handleInputChange('description', e.target.value)}
          placeholder="Brief description of the content"
          rows={3}
        />
      </div>

      {(formData.type === 'video' || formData.type === 'audio') && (
        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="url">{formData.type === 'video' ? 'Video URL *' : 'Audio URL *'}</Label>
            <Input
              id="url"
              value={formData.url || ''}
              onChange={(e) => handleInputChange('url', e.target.value)}
              placeholder={formData.type === 'video' ? 'Direct link to video file (mp4, webm, etc.)' : 'Direct link to audio file (mp3, wav, etc.)'}
              type="url"
              disabled={uploaded.media}
            />
            {uploaded.media && (
              <div className="flex items-center justify-between text-xs mt-1">
                <span className="text-green-600">Selected file: {fileNames.media}</span>
                <button
                  type="button"
                  className="text-red-500 hover:underline"
                  onClick={() => {
                    setUploaded(prev => ({ ...prev, media: false }));
                    setFileNames(prev => ({ ...prev, media: undefined }));
                    handleInputChange('url', '');
                  }}
                >Remove</button>
              </div>
            )}
          </div>

          {formData.type === 'video' && (
            <div className="space-y-2">
              <Label htmlFor="youtubeUrl" className="flex items-center gap-2">
                YouTube URL (Optional)
                {metaLoading && <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />}
              </Label>
              <div className="relative">
                <Input
                  id="youtubeUrl"
                  className={metaLoading ? 'pr-8' : ''}
                  value={formData.youtubeUrl || ''}
                  onChange={(e) => handleInputChange('youtubeUrl', e.target.value)}
                  placeholder="Paste a YouTube link to auto-fill"
                  type="url"
                />
                {metaLoading && (
                  <Loader2 className="h-4 w-4 animate-spin absolute right-2 top-1/2 -translate-y-1/2 text-muted-foreground" />
                )}
              </div>
              <p className="text-xs text-muted-foreground">
                {metaLoading ? 'Fetching metadata…' : 'Title, description, thumbnail & duration will auto-fill.'}
              </p>
            </div>
          )}
          
          <div className="space-y-2">
            <Label htmlFor="fileUpload">Or Upload File *</Label>
            <Input
              id="fileUpload"
              type="file"
              accept={formData.type === 'video' ? 'video/*' : 'audio/*'}
              onChange={(e) => {
                const file = e.target.files?.[0];
                if (file) {
                  handleInputChange('url', `uploaded-${file.name}`);
                  setUploaded(prev => ({ ...prev, media: true }));
                  setFileNames(prev => ({ ...prev, media: file.name }));
                  if (!formData.title) {
                    setFormData(prev => ({ ...prev, title: file.name.replace(/\.[^.]+$/, '').replace(/[-_]/g,' ') }));
                  }
                }
              }}
              className="file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary file:text-primary-foreground hover:file:bg-primary/80"
            />
            <p className="text-xs text-muted-foreground">
              Upload a {formData.type} file from your local machine.
            </p>
          </div>
        </div>
      )}

      {formData.type === 'article' && (
        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="url">Article URL (Optional)</Label>
            <Input
              id="url"
              value={formData.url || ''}
              onChange={(e) => handleInputChange('url', e.target.value)}
              placeholder="Direct link to article page"
              type="url"
            />
            <p className="text-xs text-muted-foreground">
              Link to an external article page or leave empty to use content field below
            </p>
          </div>
          
          {!formData.url && (
            <div className="space-y-2">
              <Label htmlFor="content">Article Content</Label>
              <Textarea
                id="content"
                value={formData.content || ''}
                onChange={(e) => handleInputChange('content', e.target.value)}
                placeholder="Article content (supports markdown)"
                rows={10}
              />
            </div>
          )}
        </div>
      )}

      {formData.type === 'story' && (
        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="url">Story Page URL (Optional)</Label>
            <Input
              id="url"
              value={formData.url || ''}
              onChange={(e) => handleInputChange('url', e.target.value)}
              placeholder="Direct link to story page"
              type="url"
            />
            <p className="text-xs text-muted-foreground">
              Link to an external story page or leave empty to add the full story below
            </p>
          </div>
          
          {!formData.url && (
            <div className="space-y-2">
              <Label htmlFor="content">Full Story Content</Label>
              <Textarea
                id="content"
                value={formData.content || ''}
                onChange={(e) => handleInputChange('content', e.target.value)}
                placeholder="Write the complete story here..."
                rows={15}
              />
              <p className="text-xs text-muted-foreground">
                Add the entire story content. This will be displayed as a full story experience.
              </p>
            </div>
          )}
        </div>
      )}

      <div className="space-y-4">
        <div className="space-y-2">
          <Label htmlFor="thumbnailUrl">Thumbnail URL *</Label>
          <Input
            id="thumbnailUrl"
            value={formData.thumbnailUrl || ''}
            onChange={(e) => handleInputChange('thumbnailUrl', e.target.value)}
            placeholder="URL to thumbnail image"
            type="url"
            disabled={uploaded.thumbnail}
          />
          {uploaded.thumbnail && (
            <div className="flex items-center justify-between text-xs mt-1">
              <span className="text-green-600">Selected file: {fileNames.thumbnail}</span>
              <button
                type="button"
                className="text-red-500 hover:underline"
                onClick={() => {
                  setUploaded(prev => ({ ...prev, thumbnail: false }));
                  setFileNames(prev => ({ ...prev, thumbnail: undefined }));
                  handleInputChange('thumbnailUrl', '');
                }}
              >Remove</button>
            </div>
          )}
        </div>
        <div className="space-y-2">
          <Label htmlFor="thumbnailUpload">Or Upload Thumbnail *</Label>
          <Input
            id="thumbnailUpload"
            type="file"
            accept="image/*"
            onChange={(e) => {
              const file = e.target.files?.[0];
              if (file) {
                handleInputChange('thumbnailUrl', `uploaded-image-${file.name}`);
                setUploaded(prev => ({ ...prev, thumbnail: true }));
                setFileNames(prev => ({ ...prev, thumbnail: file.name }));
              }
            }}
            className="file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary file:text-primary-foreground hover:file:bg-primary/80"
          />
          <p className="text-xs text-muted-foreground">Provide an image URL or upload a local image file.</p>
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="tags">Tags (comma-separated)</Label>
        <Input
          id="tags"
          value={Array.isArray(formData.tags) ? formData.tags.join(', ') : ''}
          onChange={(e) => handleTagsChange(e.target.value)}
          placeholder="anxiety, stress, relaxation"
        />
      </div>

      <div className="flex items-center space-x-2">
        <Switch
          id="isPublished"
          checked={formData.isPublished || false}
          onCheckedChange={(checked) => handleInputChange('isPublished', checked)}
        />
        <Label htmlFor="isPublished">Published</Label>
      </div>

      <div className="flex justify-end space-x-2 pt-4">
        <Button type="button" variant="outline" onClick={onClose}>
          Cancel
        </Button>
        <Button type="submit" disabled={loading}>
          {loading ? 'Saving...' : existing ? 'Update' : 'Create'}
        </Button>
      </div>
    </form>
  );
};
